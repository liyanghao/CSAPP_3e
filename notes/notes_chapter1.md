# 第一章 计算机系统之旅
通过这本书，我能学习到哪些知识和技能？
- 一些实用技能，比如**如何避免由计算机表示数的方式引起的奇怪的数值错误**等；
- 一些优化C代码的技巧，比如**如何利用现代处理器和存储系统的设计等来优化C代码的技巧**；
- **编译器如何实现函数调用，及如何利用这个知识来避免因缓冲区溢出导致的安全漏洞**；
- **如何识别和避免在链接过程中出现的令人讨厌的错误**；
- **如何编写自己的Unix shell脚本、动态内存分配包以及web服务器等**；
- **并发的优点和缺点**；

## 第1.1节 信息=位+上下文
两个重要的基本思想：
- **在一个系统里的所有信息都用bit位来表示，比如磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及跨网络传输的数据等**；
- **计算机表示的数字是对数学上的数的有限近似**；

## 第1.2节 源程序被其他程序转换成不同的形式
从源程序`.c`文件到可执行目标文件要经历4个阶段：
- 预处理阶段
- 编译阶段
- 汇编阶段
- 链接阶段
![编译系统.png](https://upload-images.jianshu.io/upload_images/7066251-6c68531a9f7bfd4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 第1.3节 理解编译器是如何工作的是一件很有价值的事情
为什么要理解编译器是如何工作？
- 优化程序性能；
- 理解链接期错误；
- 避免安全漏洞；

理解编译器如何工作能解决如下问题：
- switch语句总是比多条if-else语句的效率更高吗？
- 一次函数调用的开销有多大？
- while循环比for循环更有效率吗？
- 指针引用比数组索引更有效率吗？
- 为什么我们的循环对局部变量求和比对按引用传递的实参求和运行得更快？
- 当我们重排一个算术表达式的括号时，是如何让一个函数运行的更快的？
- 当链接器报告不能解析一个引用时，这意味着什么？
- 如果你在不同的C文件里定义了两个相同名字的全局变量，则会发生什么？
- 静态库和动态库之间的区别是什么？为什么我们在命令行上列出的库的顺序会有关系？
- 为什么有些跟链接相关的错误会直到运行时才出现？
- 数据和控制信息在程序栈中的存储方式会有哪些后果？

## 第1.5节
### 高速缓存
图1.8展示了一个典型系统中的高速缓存。
![图1.8 高速缓存.png](https://upload-images.jianshu.io/upload_images/7066251-bd7615af567c1e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- L1缓存在处理器上，可持有数万个字节，访问速度跟寄存器文件几乎一样快。
- L2缓存可持有数十万到数百万字节，通过特殊的总线连接到处理器的。
- 处理器访问L2缓存的时间要比L1缓存要长5倍，但要比内存快5到10倍。
- L1缓存和L2缓存是通过SRAM硬件技术实现的。
- 更新的、功能更强大的系统甚至有3级缓存：L1、L2、L3。

高速缓存背后的思想是：**利用局部性(程序倾向于访问在局部区域的数据和代码的趋势)来实现大且快的内存**。

两个重要教训：
- **计算机系统花大量的时间将信息从一个地方移动到另一个地方**；
- **了解高速缓存的程序员可以利用高速缓存来将程序的性能提升一个数量级**；


