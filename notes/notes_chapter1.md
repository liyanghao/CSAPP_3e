# 第一章 计算机系统之旅
通过这本书，我能学习到哪些知识和技能？
- 一些实用技能，比如**如何避免由计算机表示数的方式引起的奇怪的数值错误**等；
- 一些优化C代码的技巧，比如**如何利用现代处理器和存储系统的设计等来优化C代码的技巧**；
- **编译器如何实现函数调用，及如何利用这个知识来避免因缓冲区溢出导致的安全漏洞**；
- **如何识别和避免在链接过程中出现的令人讨厌的错误**；
- **如何编写自己的Unix shell脚本、动态内存分配包以及web服务器等**；
- **并发的优点和缺点**；

## 第1.1节 信息=位+上下文
两个重要的基本思想：
- **在一个系统里的所有信息都用bit位来表示，比如磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及跨网络传输的数据等**；
- **计算机表示的数字是对数学上的数的有限近似**；

## 第1.2节 源程序被其他程序转换成不同的形式
从源程序`.c`文件到可执行目标文件要经历4个阶段：
- 预处理阶段
- 编译阶段
- 汇编阶段
- 链接阶段
![编译系统.png](https://upload-images.jianshu.io/upload_images/7066251-6c68531a9f7bfd4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 第1.3节 理解编译器是如何工作的是一件很有价值的事情
为什么要理解编译器是如何工作？
- 优化程序性能；
- 理解链接期错误；
- 避免安全漏洞；

理解编译器如何工作能解决如下问题：
- switch语句总是比多条if-else语句的效率更高吗？
- 一次函数调用的开销有多大？
- while循环比for循环更有效率吗？
- 指针引用比数组索引更有效率吗？
- 为什么我们的循环对局部变量求和比对按引用传递的实参求和运行得更快？
- 当我们重排一个算术表达式的括号时，是如何让一个函数运行的更快的？
- 当链接器报告不能解析一个引用时，这意味着什么？
- 如果你在不同的C文件里定义了两个相同名字的全局变量，则会发生什么？
- 静态库和动态库之间的区别是什么？为什么我们在命令行上列出的库的顺序会有关系？
- 为什么有些跟链接相关的错误会直到运行时才出现？
- 数据和控制信息在程序栈中的存储方式会有哪些后果？

