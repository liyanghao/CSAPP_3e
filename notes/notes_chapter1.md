# 第一章 计算机系统之旅
通过这本书，我能学习到哪些知识和技能？
- 一些实用技能，比如**如何避免由计算机表示数的方式引起的奇怪的数值错误**等；
- 一些优化C代码的技巧，比如**如何利用现代处理器和存储系统的设计等来优化C代码的技巧**；
- **编译器如何实现函数调用，及如何利用这个知识来避免因缓冲区溢出导致的安全漏洞**；
- **如何识别和避免在链接过程中出现的令人讨厌的错误**；
- **如何编写自己的Unix shell脚本、动态内存分配包以及web服务器等**；
- **并发的优点和缺点**；

## 第1.1节 信息=位+上下文
两个重要的基本思想：
- **在一个系统里的所有信息都用bit位来表示，比如磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及跨网络传输的数据等**；
- **计算机表示的数字是对数学上的数的有限近似**；

## 第1.2节 源程序被其他程序转换成不同的形式
从源程序`.c`文件到可执行目标文件要经历4个阶段：
- 预处理阶段
- 编译阶段
- 汇编阶段
- 链接阶段
![编译系统.png](https://upload-images.jianshu.io/upload_images/7066251-6c68531a9f7bfd4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 第1.3节 理解编译器是如何工作的是一件很有价值的事情
为什么要理解编译器是如何工作？
- 优化程序性能；
- 理解链接期错误；
- 避免安全漏洞；

理解编译器如何工作能解决如下问题：
- switch语句总是比多条if-else语句的效率更高吗？
- 一次函数调用的开销有多大？
- while循环比for循环更有效率吗？
- 指针引用比数组索引更有效率吗？
- 为什么我们的循环对局部变量求和比对按引用传递的实参求和运行得更快？
- 当我们重排一个算术表达式的括号时，是如何让一个函数运行的更快的？
- 当链接器报告不能解析一个引用时，这意味着什么？
- 如果你在不同的C文件里定义了两个相同名字的全局变量，则会发生什么？
- 静态库和动态库之间的区别是什么？为什么我们在命令行上列出的库的顺序会有关系？
- 为什么有些跟链接相关的错误会直到运行时才出现？
- 数据和控制信息在程序栈中的存储方式会有哪些后果？

## 第1.5节
### 高速缓存
图1.8展示了一个典型系统中的高速缓存。
![图1.8 高速缓存.png](https://upload-images.jianshu.io/upload_images/7066251-bd7615af567c1e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- L1缓存在处理器上，可持有数万个字节，访问速度跟寄存器文件几乎一样快。
- L2缓存可持有数十万到数百万字节，通过特殊的总线连接到处理器的。
- 处理器访问L2缓存的时间要比L1缓存要长5倍，但要比内存快5到10倍。
- L1缓存和L2缓存是通过SRAM硬件技术实现的。
- 更新的、功能更强大的系统甚至有3级缓存：L1、L2、L3。

高速缓存背后的思想是：**利用局部性(程序倾向于访问在局部区域的数据和代码的趋势)来实现大且快的内存**。

3个重要教训：
- **计算机系统花大量的时间将信息从一个地方移动到另一个地方**；
- **了解高速缓存的程序员可以利用高速缓存来将程序的性能提升一个数量级**；
- **了解存储层次结构的程序员可以利用这个知识来将程序的性能提升一个数量级**；

## 第1.6节 存储层次结构
基本想法：**可在处理器和一个更大、更慢的设备(比如内存)之间插入一个更小且更快的设备(比如高速缓存)**。

存储层级结构体现的主要思想是：**某一级的存储可以充当下一级存储的缓存**。

## 第1.7节 操作系统管理着硬件
操作系统提供的抽象机制：
![图1.11 操作系统提供的抽象机制.png](https://upload-images.jianshu.io/upload_images/7066251-acf11d58eb4db6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 文件是对I/O设备的抽象；
- 虚拟内存是对内存和磁盘I/O设备的抽象；
- 进程是对处理器、内存、I/O设备的抽象。

一个进程的上下文信息包括哪些？
- PC寄存器的当前值；
- 寄存器文件的内容；
- 内存的内容等信息；

一次上下文切换的过程：
- 保存当前进程的内容；
- 还原新进程的上下文；
- 将控制权交给新进程。

一个Linux进程的内存视图是怎样的？
![图1.13 进程的虚拟地址空间.png](https://upload-images.jianshu.io/upload_images/7066251-b3fdc7e613504c5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 程序代码区和数据区
所有进程的代码都从相同的固定地址开始，接下来是对应全局C变量的数据位置。直接用可执行目标文件的内容来给代码区和数据区初始化。
- 堆
紧挨着代码区和数据区的是运行时堆。跟代码区和数据区不一样，堆会随着运行时对C标准库函数的调用(比如`malloc`和`free`)而动态增长和缩小。
- 共享库
靠近地址空间中部的区域是一个持有共享库(比如C语言标准库和数学库)代码和数据的区域。
- 栈
在用户虚拟地址空间的最顶部是用户栈，编译器使用栈来实现函数调用。跟堆一样，用户栈也能在程序执行时动态增长和缩小。特别地，每次我们调用一个函数，用户栈就增长。每次我们从一个函数中返回，用户栈就缩小。
- 内核虚拟内存
地址空间的最顶部区域是预留给内核的。应用程序不允许读或写这块区域的内容，不允许直接调用定义在内核代码中的函数。应用程序要触发内核让内核来执行这些操作。

让虚拟内存生效的一个基本想法是**将一个进程的虚拟内存的内容存储在磁盘上，然后使用内存作为该磁盘内容的缓存**。


## 总结
使程序运行的更快有哪些方式？
- 理解编译器是如何工作的
- 理解高速缓存
- 理解存储层次结构
- 使用多线程
- 理解超标量处理器模型






