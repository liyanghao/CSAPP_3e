本章的主要内容有：
- 2.1节 信息的存储
- 2.2节 整数的表示
- 2.3节 整数的运算
- 2.4节 浮点数
- 2.5节 总结

现代计算机存储和处理表示为二值信号的信息。这些二进制数位形成了数字革命的基础。

我们熟悉的10进制数由印度人发明，已在印度使用了超过1千年，在12世纪阿拉伯数学家对其进行了改进，在13世纪意大利数学家Fibonacci将其引进西方。

对有10个手指的人类来说，使用十进制是很自然的事，但当建造存储和处理信息的机器时，二进制数更好用。二值信号容易表示、存储和传输，比如打孔卡上是否有洞、电线上的电压是高还是低、磁场的方向是顺时针还是逆时针等。基于二值信号的存储和执行计算的电路非常简单和可靠，使得制造商可在一个硅芯片上集成数百万甚至数十亿个这样的电路。

单独地看一个位并不是很有用。但是，**当我们将位分组在一起，并进行某种解释时，就让不同的位模式有了含义，这样我们就能表示任意一个有限集的元素**。比如，使用一个二进制数系统，我们能使用位组来编码非负整数。通过使用一个标准的字符码，我们能对一个文档里的字符和符号进行编码。我们在本章里会覆盖这两部分编码方式，以及非负数的编码表示和实数的近似表示等。

我们考虑3种重要的数字表示方法：
- 无符号数表示法
基于传统的二进制记号，表示大于等于0的整数。
- 补码表示法
最常用的表示有符号整数的方法。
- 浮点数表示法
使用二进制记号的科学计数法来表示实数。

使用不同表示方法实现的计算机整数算术运算跟数学上的整数算术运算类似。
- 计算机上的整数算术运算满足数学上的整数算术运算的大部分性质，比如乘法满足结合律、交换律等。
```
(500*400)*(300*200)=-884901888
((500*400)*300)*200=-884901888
((200*500)*300)*400=-884901888
400*(200*(300*500))=-884901888
```
- 由于计算机使用有限个位来编码一个数，因此当操作的结果太大而不能被表示时，则该操作就溢出了。这会导致一些令人惊讶的结果。比如，在今天的大部分计算机上，表达式`200*300*400*500`的值为-884901888。这个结果违背了数学上的整数运算的性质，即一组正整数的乘积是一个负数。

计算机上的浮点数算术运算跟数学上的实数的算术运算有着不同的性质。
- 一组正数的乘积会溢出会得到正无穷$+\infty$。
- 一组正数的乘积乘积通常都是正数。
- 由于浮点数表示方法的精度有限，所以计算机上的浮点数运算不满足结合律，比如表达式`(3.14+1e20)-1e20`的值为0，表达式`3.14+(1e20-1e20)`的值为0。




计算机的整数运算和浮点数运算有着不同的数学性质源于它们处理表示有限性的方式不同：**整数的表示能精确地编码相对小范围的数值，而浮点数的表示能近似地编码相对大范围的数值**。

通过研究计算机上数的实际表示方法，我们能理解该方法可以表示的数值范围，以及不同算术运算的性质。这种理解对编写所有数值范围都正确运行的程序及可跨机器、操作系统及编译器等移植的程序是很关键的。如我们将要描述的那样，由于计算机算术运算跟数学运算间的微妙差别，所以出现了许多计算机安全漏洞。在早期，程序错误碰巧发生时只会给人们带来不便。现在有多个黑客团伙试图利用其发现的任何错误来获得对他人系统的非法访问。这就使得程序员有更高的义务来理解他们的程序如何执行，以及怎样使程序以不可期的方式运行。

计算机使用多种不同的二进制表示方式来编码数值。随着你在第3章里接触到机器语言编程，你需要熟悉这些表示方式。我们在本章里描述这些编码，向你展示如何合理分析数的二进制表示。通过直接操作数字的位表示，我们得出了许多方法来执行算术运算。理解这些技术对理解编译器在尝试优化算术表达式求值的性能时生成的机器码很重要。

我们是基于一组核心的数学原理来处理这份材料的。我们从编码的基本定义开始，然后导出一些性质，比如可表示的数的范围、它们的位级别表示、算术运算性质等。我们相信从这种抽象角度来学习这份材料对你来说很重要，因为程序员需要清楚地理解计算机算术运算跟我们熟悉的整数与实数运算之间的联系和区别。

- C++是基于C构建的，跟C使用的是相同的数值表示方法和操作。在本章中对C讲述的理论对于C++同样成立。
- Java语言定义创造一套新的数值表示和操作的标准。
- C标准支持更多的实现，Java标准有着非常具体的数据格式和编码。
- 在本章里，我们会在多处重点介绍由Java支持的表示和操作。

## 第2.1节 存储信息
不是访问内存中的单个位，大部分计算机使用字节(由8个位组成的块)作为内存访问的最小单元。

机器码程序将内存看成是一个非常大的字节数组，即**虚拟内存**。每一个内存字节都由一个地址(一个唯一的数)确定，所有可能的地址构成了**虚拟地址空间**。如名字所示，这个虚拟地址空间只是一个展示给机器码程序的概念上的视图。实际的实现(在第9章里)综合使用了DRAM、闪存、磁盘、特殊硬件以及操作系统来给程序提供看似是单个的字节数组。

在接下来的章节里，我们将描述编译器和运行时系统如何将这个内存空间划分成更多的可管理的单元来存储不同的程序对象，包括程序数据、指令、控制信息等。使用了各种各样的机制来分配和管理不同程序部分的存储。这种管理都是在虚拟地址空间中执行的。比如，在C语言中的指针的值(不管该指针指向的是一个整数还是结构体或者其他程序对象)是某个内存块的首个字节的虚拟地址。C编译器也给每个指针分配类型信息，以便能生成不同的机器码，根据值的类型来访问指针指向的地址中存储的值。虽然由C编译器来维护这种类型信息，但是实际生成的机器码程序却没有数据类型相关的任何信息。机器码程序简单地将每个程序对象看做是一个字节块，将程序自身看做是字节序列。

### 第2.1.1小节 十六进制表示法






