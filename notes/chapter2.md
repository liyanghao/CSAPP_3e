本章的主要内容有：
- 2.1节 信息的存储
- 2.2节 整数的表示
- 2.3节 整数的运算
- 2.4节 浮点数
- 2.5节 总结

现代计算机存储和处理表示为二值信号的信息。这些二进制数位形成了数字革命的基础。

我们熟悉的10进制数由印度人发明，已在印度使用了超过1千年，在12世纪阿拉伯数学家对其进行了改进，在13世纪意大利数学家Fibonacci将其引进西方。

对有10个手指的人类来说，使用十进制是很自然的事，但当建造存储和处理信息的机器时，二进制数更好用。二值信号容易表示、存储和传输，比如打孔卡上是否有洞、电线上的电压是高还是低、磁场的方向是顺时针还是逆时针等。基于二值信号的存储和执行计算的电路非常简单和可靠，使得制造商可在一个硅芯片上集成数百万甚至数十亿个这样的电路。

单独地看一个位并不是很有用。但是，**当我们将位分组在一起，并进行某种解释时，就让不同的位模式有了含义，这样我们就能表示任意一个有限集的元素**。比如，使用一个二进制数系统，我们能使用位组来编码非负整数。通过使用一个标准的字符码，我们能对一个文档里的字符和符号进行编码。我们在本章里会覆盖这两部分编码方式，以及非负数的编码表示和实数的近似表示等。

我们考虑3种重要的数字表示方法：
- 无符号数表示法
基于传统的二进制记号，表示大于等于0的整数。
- 补码表示法
最常用的表示有符号整数的方法。
- 浮点数表示法
使用二进制记号的科学计数法来表示实数。

使用不同表示方法实现的计算机整数算术运算跟数学上的整数算术运算类似。
- 计算机上的整数算术运算满足数学上的整数算术运算的大部分性质，比如乘法满足结合律、交换律等。
```
(500*400)*(300*200)=-884901888
((500*400)*300)*200=-884901888
((200*500)*300)*400=-884901888
400*(200*(300*500))=-884901888
```
- 由于计算机使用有限个位来编码一个数，因此当操作的结果太大而不能被表示时，则该操作就溢出了。这会导致一些令人惊讶的结果。比如，在今天的大部分计算机上，表达式`200*300*400*500`的值为-884901888。这个结果违背了数学上的整数运算的性质，即一组正整数的乘积是一个负数。

计算机上的浮点数算术运算跟数学上的实数的算术运算有着不同的性质。
- 一组正数的乘积会溢出会得到正无穷$+\infty$。
- 一组正数的乘积乘积通常都是正数。
- 由于浮点数表示方法的精度有限，所以计算机上的浮点数运算不满足结合律，比如表达式`(3.14+1e20)-1e20`的值为0，表达式`3.14+(1e20-1e20)`的值为0。




计算机的整数运算和浮点数运算有着不同的数学性质源于它们处理表示有限性的方式不同：**整数的表示能精确地编码相对小范围的数值，而浮点数的表示能近似地编码相对大范围的数值**。

通过研究计算机上数的实际表示方法，我们能理解该方法可以表示的数值范围，以及不同算术运算的性质。这种理解对编写所有数值范围都正确运行的程序及可跨机器、操作系统及编译器等移植的程序是很关键的。如我们将要描述的那样，由于计算机算术运算跟数学运算间的微妙差别，所以出现了许多计算机安全漏洞。在早期，程序错误碰巧发生时只会给人们带来不便。现在有多个黑客团伙试图利用其发现的任何错误来获得对他人系统的非法访问。这就使得程序员有更高的义务来理解他们的程序如何执行，以及怎样使程序以不可期的方式运行。

计算机使用多种不同的二进制表示方式来编码数值。随着你在第3章里接触到机器语言编程，你需要熟悉这些表示方式。我们在本章里描述这些编码，向你展示如何合理分析数的二进制表示。通过直接操作数字的位表示，我们得出了许多方法来执行算术运算。理解这些技术对理解编译器在尝试优化算术表达式求值的性能时生成的机器码很重要。

我们是基于一组核心的数学原理来处理这份材料的。我们从编码的基本定义开始，然后导出一些性质，比如可表示的数的范围、它们的位级别表示、算术运算性质等。我们相信从这种抽象角度来学习这份材料对你来说很重要，因为程序员需要清楚地理解计算机算术运算跟我们熟悉的整数与实数运算之间的联系和区别。

- C++是基于C构建的，跟C使用的是相同的数值表示方法和操作。在本章中对C讲述的理论对于C++同样成立。
- Java语言定义创造一套新的数值表示和操作的标准。
- C标准支持更多的实现，Java标准有着非常具体的数据格式和编码。
- 在本章里，我们会在多处重点介绍由Java支持的表示和操作。

## 第2.1节 存储信息
不是访问内存中的单个位，大部分计算机使用字节(由8个位组成的块)作为内存访问的最小单元。

机器码程序将内存看成是一个非常大的字节数组，即**虚拟内存**。每一个内存字节都由一个地址(一个唯一的数)确定，所有可能的地址构成了**虚拟地址空间**。如名字所示，这个虚拟地址空间只是一个展示给机器码程序的概念上的视图。实际的实现(在第9章里)综合使用了DRAM、闪存、磁盘、特殊硬件以及操作系统来给程序提供看似是单个的字节数组。

在接下来的章节里，我们将描述编译器和运行时系统如何将这个内存空间划分成更多的可管理的单元来存储不同的程序对象，包括程序数据、指令、控制信息等。使用了各种各样的机制来分配和管理不同程序部分的存储。这种管理都是在虚拟地址空间中执行的。比如，在C语言中的指针的值(不管该指针指向的是一个整数还是结构体或者其他程序对象)是某个内存块的首个字节的虚拟地址。C编译器也给每个指针分配类型信息，以便能生成不同的机器码，根据值的类型来访问指针指向的地址中存储的值。虽然由C编译器来维护这种类型信息，但是实际生成的机器码程序却没有数据类型相关的任何信息。机器码程序简单地将每个程序对象看做是一个字节块，将程序自身看做是字节序列。

### 第2.1.1小节 十六进制表示法
一个字节由8个位组成。使用二进制表示，一个字节的值的范围是从$(00000000)_2$到$(11111111)_2$。使用十进制表示，一个字节的范围是从$0_{10}$到$255_{10}$。注意：**使用这两种进制表示来描述位模式不方便**。二进制表示太冗长，十进制和二进制之间的转换太繁琐。相反，我们使用十六进制来描述位模式。

十六进制使用数字0到数字9、字符A到字符F来表示16个可能的值。图2.2里展示了16个16进制数及其对应的十进制数和二进制数。
![图2.2 十六进制数.png](https://upload-images.jianshu.io/upload_images/7066251-c8e4d432bc374322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在C语言中，以`0x`或者`0X`开头的数值常数被解释成十六进制数。字符A和字符F可写成大写或者小写。比如我们写数字$FA1D37B$为`oxFA1D37B`或者`oxfa1d37b`等。在本书中，将使用C语言的记号来表示16进制数。

机器码程序的常见的任务是手动在十进制、二进制、16进制间转换。二进制和16进制的转换非常直接，因为可一次对一个十六进制数做转换。可参考图2.2中的表格来对数字做转换。在脑海中做转换时的一个简单的技巧是：记住十六进制数A、C、F对应的十进制数。十六进制数B、D、F可通过计算其相对A、C、F的值来做转换。

比如，假设给你一个数`0x173A4C`。你可通过展开每个十六进制数来将该数转换成二进制格式，该十六进制数对应的二进制表示为`000101110011101001001100`。
![0x173A4C.png](https://upload-images.jianshu.io/upload_images/7066251-be16d4d8862c29f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

反过来，给定一个二进制数`1111001010110110110011`，通过按照每4位分成一组，你可以将该数转换成十六进制。注意，如果整个数的位数不是4的整数倍，则你应该给最左一组的数的前面补0。然后将每个位组转换成相应的十六进制数：
![2to16.png](https://upload-images.jianshu.io/upload_images/7066251-84e6e6a605ad5e05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当x是2的幂次方时，即存在某个非负整数n使得$x=2^n$，则x的十六进制形式很容易写：只要记住x的二进制表示是1后面跟n个0。由于十六进制的0表示4个二进制的0。所以，对可表示成i+4j的n，其中$0\leq i\leq 3$，则$x=2^{i+4j}=2^i\times (2^4)^j$的十六进制形式为开头数字为十六进制数1(i=0)或者2(i=1)或者4(i=2)或者8(i=3)，后跟j个十六进制的0。比如，对于$x=2048=2^11$，有$n=11=2\times 4+3$，则x的十六进制形式为`0x800`。

十进制跟十六进制之间的转换需要使用乘法或者除法来处理一般情形。为了将十进制数x转换成16进制，我们首先把x除以16，得商为q，余数为r，使得$x=q\times 16+r$。然后使用r作为16进制表示的最低位，且对商q重复执行前述过程得到剩余的16进制数字。比如，将十进制数`314,156`转换为16进制的过程为：
```
314,156 = 19,634*16 + 12(C)
19634 = 1,227*16+2(2)
1,227 = 76*16+11(B)
76=4*16+12(C)
4=0*16+4(4)
```
从上可知：十进制数`314,156`的十六进制形式为`0x4CB2C`。

相反，为了将16进制数转成十进制数，则用每个16进制数乘以适当的16的幂次方。比如，对于16进制数`0x7AF`，相应的十进制数为$7\times 16^2+10\times 16^1+15=7\times 256+10\times 16+15=1,967$。

### 第2.1.2小节 数据范围
每台计算机都有一个字大小，用来表示指针类型数据的标准大小。因为一个虚拟地址是由一个字编码的，所以由字大小确定的最重要的系统参数就是虚拟地址空间的最大值。也就是说，对于一台字大小为w位的机器，它的虚拟地址的范围是从$0$到$2^{w}-1$，即一个程序最多能访问$2^w$个字节。

最近这些年，有很多从32位字大小的机器到64位字大小机器的迁移。首先发生在为大规模科学计算应用和数据库应用上，然后是桌面机器和台式机器，最近发生在智能手机上。一台32位字长的机器限制了虚拟地址空间的大小为4GB，大约刚超过$4\times 10^9$字节。一台64位字长的机器限制了虚拟地址空间的大小为16 exabytes，大约是$1.84\times 10^{19}$字节。

大部分64位机器是向后兼容的，即也可以运行为32位机器编译的程序。比如，当一个程序`prog.c`是用下面指令编译的：
```
linux> gcc -m32 prog.c
```
然后该程序既能在32位机器上运行，也能在64位机器上运行。另一方面，使用如下指令编译的程序只能在64位机器上运行：
```
linux> gcc -m64 prog.c
```
由于区分是一个程序如何被编译，而不是它运行的机器类型，因此，我们将引用程序为`32位程序`或者`64位程序`。

计算机和编译器支持使用不同编码数据方式的多种数据格式，比如不同长度的整数、浮点数等。比如许多机器有操作单个字节的指令，也支持2字节整数、4字节整数、8字节整数，也支持4字节浮点数、8字节浮点数等。

C语言支持多种数据格式的整数、浮点数数据。图2.3展示了分配给C语言不同数据类型的字节的个数。某些数据类型的精确字节数取决于程序如何被编译。我们展示了典型的32位程序和64位程序。
![C语言典型数据类型的大小.png](https://upload-images.jianshu.io/upload_images/7066251-5e2648ce445b100a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 整数数据可以是能表示0、负数、正数的无符号数，也可以是仅允许非负数的无符号数。
- `char`类型用一个字节表示。虽然名称`char`是从“char用来存储文本字符串中的单个字符”这个事实中推导出的，但是`char`类型也可用来存储整数值。
- 数据类型`short`、`int`、`long`旨在提供范围不同的数据。即使在64位机器上编译，数据类型`int`通常占4个字节。数据类型`long`在32位机器上是4个字节，在64位机器是8个字节。
- 为了避免依赖典型大小和不同编译器设置的麻烦，`ISO C99`标准引入了一类跟编译器和机器设置无关的、大小固定的数据类型，比如占4个字节的数据类型`int32_t`、占8个字节的数据类型`int64_t`等。**对程序员来说，使用固定大小的数据类型是对数据格式进行严格控制的最好方式**。
- 大部分机器也支持两种不同的浮点数格式：单精度和双精度，在C语言中分别声明为占4个字节的float、8个字节的double。
- 大部分数据类型都编码的是有符号整数，除非前缀有`unsigned`或者使用固定大小数据类型的具体无符号声明。此处有个例外：数据类型`char`。虽然大部分编译器和机器将数据类型`char`看做是有符号数据，但是C语言规范并没有提供这种保证。相反，根据方括号的提示，程序员应该使用声明`signed char`来保证一个字节的有符号值。但是，在许多上下文里，程序对数据类型`char`是有符号的还是无符号的并不敏感。
- 一个指针使用的是程序的整个字长。

C语言允许多多种方式来给关键字排序、包含或者省略可选关键字。比如，下面所有的声明都有相同的含义：
```
unsigned long
unsigned long int
long unsigned
long unsigned int
```


程序员应尽力使程序能跨平台和机器移植。可移植性的一个要求程序对不同数据类型的具体大小不敏感。

**虽然C语言规范设置了不同数据类型的数值范围的下界，但是并没有设置上界，除了固定大小的数据类型外**。从20世纪80年代到2010年，由于32位机器和32位程序是主流的组合，所以许多程序一直都是根据图2.3里的列出的32位假设分配而编写的。随着迁移程序到64位机器上，许多隐藏的字大小依赖会作为错误出现。比如，许多程序员历史性地假设一个声明为int数据类型的对象能用来存储指针。虽然这对于大部分32位程序是正确的，但是对64位程序会导致问题。









