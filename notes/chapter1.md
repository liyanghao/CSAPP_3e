计算机系统是由硬件和系统软件组成的，其中硬件和系统软件一起工作来运行应用程序。**虽然系统的具体实现随着时间而变化，但是系统底层的概念是不变的**。所有的计算机系统都有相似的硬件和系统软件等组成部分，这些硬件和系统软件执行着相似的功能。这本书是为希望通过了解硬件和系统软件如何工作、如何影响程序的正确性和性能来提高自己技能的程序员而写的。

你要为一个令人激动的旅行做好准备。如果你致力于学习本书中的概念，那么你将受对底层计算机系统的理解及这种理解对应用程序的影响所启发，踏上成为稀有的程序员之路。
- 你将学习到一些实用技能，比如如何避免由计算机表示数的方式引起的奇怪的数值错误等；
- 你将学习到如何使用那些利用了现代处理器和存储系统的技巧来优化C代码；
- 你将学习到编译器如何实现函数调用及如何利用这个知识来避免因缓冲区溢出导致的安全漏洞；
- 你将学习到如何识别和避免在链接过程中出现的令人讨厌的错误；
- 你将学习到如何编写自己的Unix shell脚本、动态内存分配包以及web服务器等；
- 你将学习到并发的优点和缺点；

在C语言的经典教材`K&R`里，Kernighan和Ritchie使用图1.1所示的`hello`程序来给读者讲解C语言。
![图1.1 hello程序.png](https://upload-images.jianshu.io/upload_images/7066251-2108f5a6d4fd2869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们通过追踪`hello`程序的生命周期来开始系统研究之路：从由程序员创建`hello`程序开始，直到该程序在系统上运行，输出简单的消息，终止结束。沿着该程序的生命周期，我们会简要介绍一些会用到的核心概念、术语、组成部分等。在后面的章节里，我们会拓展这些思想。
## 第1.1节 信息=位+上下文
`hello`程序以源文件`hello.c`开始它的生命。`hello.c`源文件是由位组成的序列，每个位的值要么是0，要么是1。每个字节表示源程序中的一个文本字符。

大部分计算机系统使用ASCII标准来表示文本字符，其中ASCII标准使用一个唯一的、字节大小的整数值来表示一个字符。比如图1.2里展示了`hello.c`的ASCII表示。
![图1.2 hello.c的ASCII文本表示.png](https://upload-images.jianshu.io/upload_images/7066251-88fc06931c9ff1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`hello.c`是以字节序列形式保存在一个文件里的。每个字节有一个整数值，该整数值对应一个字符。比如，第一个字节的整数值是35，对应字符`#`。第2个字节的整数值是105，对应的字符是`i`。注意，每个文本行以不可见的新行符`\n`结尾，新行符`\n`对应的整数值是10。诸如`hello.c`等由大量ASCII字符组成的文件叫文本文件，所有其他文件叫二进制文件。

`hello.c`的表示展示了一个基本思想：**在一个系统里的所有信息都用bit位来表示，比如磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及跨网络传输的数据等**。唯一可用来区分不同数据对象之间的是我们使用数据对象的上下文。比如，在不同的上下文里，相同的字节序列可表示一个整数、浮点数、字符串或者一个机器指令。

作为程序员，我们需要理解数字的机器表示，因为计算表示的数字跟数学上的整数和实数不一样。**计算机表示的数字是对数学上的数的有限近似**。这种基本思想将在第2章中详细地探讨。

## 第1.2节 源程序被其他程序转换成不同的形式
`hello`程序以高级C程序开始，因为这种形式能被人类阅读和理解。但是，为了在系统上运行`hello.c`，每条C语句必须被其他程序转换成低级的机器语言指令序列。这些指令被打包成可执行目标程序，保存在一个二进制磁盘文件里。目标程序也被引用为可执行目标文件。

在Unix系统上，从源文件到目标文件的转换是被编译器驱动执行的：
```
linux> gcc -o hello hello.c
```
这里，GCC编译器驱动读取文件`hello.c`，将它转换成可执行目标文件`hello`。在图1.3里展示了转换的四个阶段。执行这4个阶段(预处理器、编译器、汇编器、链接器)的程序汇总起来就是编译系统。
![图1.3 编译系统.png](https://upload-images.jianshu.io/upload_images/7066251-f894fb3cd305f81e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从源文件到可执行目标文件要经历4个过程：
- 预处理阶段
预处理器cpp根据以`#`号开头的预处理器指令来修改最初的C程序。比如，在`hello.c`里第一行的`#include<stdio.h>`告诉预处理器读取系统头文件`stdio.h`里的内容直接插入源程序文本中。结果是另一个C程序`hello.i`。
- 编译阶段
编译器cc1将文本文件`hello.i`转换成文本文件`hello.s`。hello.s文件中包含一个汇编语言程序，包括了main函数的定义：
```
1    main:
2         subq    $8, %rsp
3         movl    $.LC0, %edi
4         call    puts
5         movl    $0, %eax
6         addq    $8, %rsp
7         ret
```
在这个定义里的第2-7行的每一行以文本形式描述了一个底层的机器语言指令。汇编语言非常有用，因为汇编语言为不同语言的不同编译器提供一个公共的输出语言。比如，C编译器和Fortran编译器都使用相同的汇编语言生成输出文件。
- 汇编阶段
汇编程序as将`hello.s`转换成机器语言指令，按照可重定向目标程序的格式来打包机器语言指令，把结果存储在目标文件`hello.o`中。`hello.o`文件是一个二进制文件，包含了17个字节，用于main函数的指令编码。如果我们使用文本编辑器打开`hello.o`文件，则会出现乱码。
- 链接阶段
注意到`hello`程序调用了`printf`函数，其中`printf`函数是由每个C编译器提供的C标准库的一部分，驻留在一个单独的预编译号的目标文件`printf.o`里。链接器处理的就是`printf.o`文件跟`hello.o`程序的合并。结果是`hello`可执行目标文件：可被加载进内存，被系统执行。

### 第1.3节 理解编译系统的工作机制是值得的

对于诸如hello.c等的简单程序，我们可以依靠编译系统来产生正确的、有效的机器码。但是，对于程序员为什么需要理解编译系统的工作机制有几个重要原因：
- 优化程序性能
现代编译器是可以产生优秀代码的先进工具。作为程序员，为了编写效率高的代码，我们并不需要知道编译器的内部工作机制。但是，为了在写C程序时能做出好的代码决策，我们确实需要能基本理解机器码，以及编译器是给如何将不同的C语句转换成机器码的。比如，switch语句总是比多条if-else语句更有效率吗？一次函数调用的开销有多大？while循环比for循环更有效率吗？指针引用比数组索引更有效率吗？为什么对局部变量求和比对按引用传递的实参更有效率？当我们重排一个算术表达式的括号时，是如何让一个函数运行的更快的？
在第3章里，我们介绍`X86-64`，这是Linux、Macintosh、Windows等计算机较近代的机器语言。我们描述编译器是如何将C语言的各种结构转换成x86-64机器语言。在第5章里，你将学习到通过对C代码做简单的变换来优化C程序的性能，这样做可以帮助编译器更好地做好自身的工作。在第6章里，你将学习到有关存储系统的分层本质、C编译器是如何在内存中存储数组数据的以及C程序是怎样利用存储系统相关知识来运行的更有效率。
- 理解链接期错误
根据我们的经验，一些最复杂的编程错误跟链接器的操作有关，尤其是当你在尝试构建大型软件系统时。比如，当链接器报告不能解析一个引用时，这意味着什么？如果你在不同的C文件里定义了两个相同名字的全局变量，则会发生什么？静态库和动态库之间的区别是什么？为什么我们在命令行上列出的库的顺序会有关系？最可怕的是，为什么有些跟链接相关的错误会直到运行时才出现？你将在第7章里找到这些问题的答案。
- 避免安全漏洞
多年以来，缓冲区溢出漏洞已经成为在网路服务器和因特网服务器上发生的许多安全漏洞的原因。这些漏洞之所以存在，是因为很少有程序员能认识到**有必要仔细地限制从未授信的来源接收的数据量和数据形式**。学习安全编程的第一步就是理解在程序栈中数据和控制信息的存储方式会有哪些后果。作为我们研究汇编语言的一部分，我们将在第3章里覆盖程序栈和缓冲区溢出漏洞等主题。我们也将学习到被程序员、编译器、操作系统用来降低攻击威胁的方法。

## 第1.4节 处理器读取和解释存储在内存中的指令
现在，我们的hello.c源程序已被编译系统转换成存储在磁盘上的可执行目标文件hello。为了在Unix系统上运行hello，我们在shell程序里键入它的名字：
```
linux> ./hello 
hello, world
linux>
```
Shell程序是一个命令行解释器：输出一个提示符，等待着你在命令行上键入命令，然后执行命令。如果在命令上的第一个词并不对应一个内置的shell命令，则shell会假设它是一个应该被它加载和运行的可执行目标文件的名字。所以，在这种情况下，shell程序就加载和运行hello程序，然后等着hello程序运行结束。hello程序在屏幕上输出消息后结束运行。shell程序然后输出一个提示符，等待着下一个命令行输入。
### 第1.4.1小节 系统的硬件组织
为了理解运行hello程序时发生了什么，我们需要理解图1.4展示的典型系统的硬件组织。虽然该图是根据最新的Intel系统绘制的，但是所有的系统是相似的。现在别担心这张图有多复杂。我们会在全书的课程里分阶段介绍这张图的细节。
![图1.4 典型系统的硬件组织.png](https://upload-images.jianshu.io/upload_images/7066251-4f90ea3e46227c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 总线
总线是连接整个系统的电路集合，这些总线电路在组件间来回传输字节信息。总线常被设计成传输固定大小的字节块(称为字word)数据。在一个字中的字节数是一个基本的系统参数，该参数在不同的系统中是不同的。今天的大部分机器的字长要么是4字节(32位)，要么是8字节(32位)。在本书中，我们不对字长大小做固定假设，而是在需要定义字长的上下文里定义字长是什么。
#### 输入输出设备
输入输出设备连接的是系统跟外部世界。在我们的示例系统里有4个输入输出设备：键盘、鼠标、显示器、磁盘等。最初，可执行程序hello驻留在磁盘里。

每个输入输出设备要么通过控制器、要么通过适配器连接到I/O总线上。适配器和控制器的主要区别就是集成方式不一样。控制器是设备自身上的芯片组或者系统主板上的芯片组。适配器是可插入主板卡槽的一张卡。无论如何，两者的功能都是在I/O总线和I/O设备间来回传输信息。

第6章会对磁盘等设备如何工作做更多的介绍。在第10章里，你将学习到如何使用Unix的I/O接口来从应用程序中访问设备。虽然我们重点关注网络相关的一类设备，但是相关技术也可以推广到其他类型的设备。
#### 主内存
主内存是一种临时存储设备：当处理器执行程序时，主内存同时持有程序和程序操作的数据。从物理上看，主内存由DRAM芯片组成。从逻辑上看，主内存被组成字节数组，其中每个字节都有唯一从0开始的索引。通常，构成程序的每条机器指令可由可变数量的字节组成。C程序变量对应的数据项的大小是根据类型而变化的。比如，在一台运行着Linux的X86-64的机器上，short类型需要2个字节，int类型需要4个字节，long类型需要8个字节。

第6章会对诸如DRAM芯片等存储技术如何工作，以及如何整合这些存储技术形成主内存等做详细的描述。
### 处理器
处理器是一个执行保存在主内存中的指令的引擎，其核心是程序计数器。程序计数器是一个存储单元是字大小的存储设备。在任何一个时间点，程序计数器都指向在主内存中的某个机器指令。

从系统加电到电源关闭，处理器重复执行由程序计数器指向的指令，更新程序计数器的值为下一条指令的地址。处理器似乎是根据由指令集架构定义的非常简单的执行模型来运作的。在这种模型里，指令按照严格的顺序来执行，执行单条指令可能需要若干步。处理器从程序计数器指向的内存处读取指令，解释指令中的位，根据指令的指示执行简单的操作，然后更新程序计数器的值指向下一条指令的地址，注意下一条指令的地址可能跟也可能不跟先前执行的指令在内存中是连续的。

存在一些只围绕主内存、寄存器文件、ALU运行的简单指令。寄存器问文件是一个小型设备，由存储单元是字大小的寄存器组成，每个寄存器都有唯一的名字。ALU用来计算新的数据和地址值。这里有一些CPU可能会在指令请求下指令的简单操作示例：
- Load操作
从主内存中拷贝一个字节或者一个字到寄存器，副作用是会覆盖先前在寄存器中的内容。
- Store操作
从寄存器中拷贝一个字节或者一个字到主内存中的位置，副作用是会覆盖那个位置先前的内容。
- Operate操作
拷贝两个寄存器的值到ALU中，对这两个字执行算术操作，把结果存储到某个寄存器中，副作用是会覆盖那个寄存器先前的值。
- Jump操作
从指令中抽取一个字，拷贝该字到程序计数器中，副作用是会覆盖PC中先前的值。

我们说处理器似乎是其指令集架构的一个简单实现，但是实际上现代处理器使用了更复杂的机制来加速程序执行。因此，我们可以区分处理器的指令集架构和微架构，其中指令集架构描述了每个机器指令的作用，微体系架构描述了处理器实际上是如何实现的。当我们在第3章里研究机器码时，我们将会考虑由机器的指令集架构提供的抽象机制。第4章会对处理器实际上是如何实现的做更多的介绍。第5章描述了一个处理器是如何工作的模型，该模型使得预测和优化机器语言的程序的性能成为可能。
### 第1.4.2小节 运行hello程序
有了系统硬件组织和操作的简单视图，我们就能理解运行hello程序时发生了什么。我们必须省略许多细节留待后面来补充，但是现在我们将对整体情况感到满意。

最初，shell程序在执行指令，等待着我们键入命令。如图1.5所示，随着我们键入字符`./hello`，shell程序将每个字符读入一个寄存器，然后把字符存储在内存中。

![图1.5.png](https://upload-images.jianshu.io/upload_images/7066251-f5112ccdc703d6e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当我们敲击enter键时，shell程序知道我们已完成命令的键入。然后，shell程序执行一系列指令，将hello可执行目标文件里的代码和数据从磁盘拷贝到内存。包含`hello, world\n`的数据最终将被打印输出。

如图1.6所示，可使用DMA技术将数据直接从磁盘传输到内存，不需用经过处理器。
![图1.6.png](https://upload-images.jianshu.io/upload_images/7066251-60e6de689c76ba79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图1.7所示，一旦hello目标文件的代码和数据被加载到内存，处理器就开始执行在hello程序里的main函数里的机器指令。这些指令将字符串`hello, world\n`中的字节从内存拷贝到寄存器文件，然后从寄存器文件拷贝到显示器上，在显示器上输出该字符串。
![图1.7.png](https://upload-images.jianshu.io/upload_images/7066251-b1a3377c26187a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 第1.5节 缓存相关
从前述简单示例中得到的一个重要教训就是：**系统花大量的时间将信息从一个地方移动到另一个地方**。最初，hello程序的机器指令是保存在磁盘上的。当hello程序被加载时，hello程序里的机器指令被从磁盘拷贝到内存。当处理器开始运行hello程序时，再把hello程序里的机器指令从内存拷贝到处理器里。类似的，最初在磁盘上的字符串`hello,world\n`数据被拷贝到内存，然后从内存拷贝到显示设备。从程序员的角度看，这类拷贝中的大部分都是减慢hello程序实际运行的开销。因此，系统设计者的一个主要目标就是使得这类拷贝操作尽可能地快。

根据物理定律：越大的设备比越小的设备慢；构建越快的设备比越慢的设备更昂贵。比如，在一个典型系统上的磁盘驱动要比内存慢1千倍，处理器从磁盘上读取一个字花费的时间要比从内存中慢1千万倍。

类似的，一个典型的寄存器文件只能存储几百字节的信息，而在内存中则可以存储上百亿字节。处理器从寄存器文件里读取数据要比内存中快1百倍。更糟的是，随着半导体技术近年来的进步，这种处理器-内存的差距持续加大。使处理器运行更快要比使内存运行更快来的更容易、成本更低。

为了处理处理器跟内存之间的差距，系统设计者引入了高速缓存，这些更小更快的设备充当的是处理器可能在将来需要的信息临时暂存区。图1.8展示了一个典型系统中的高速缓存。在处理器上的L1缓存可持有数万个字节，访问速度跟寄存器文件几乎一样快。可持有数十万到数百万字节的更大的L2缓存是通过特殊的总线连接到处理器的。处理器访问L2缓存的时间要比L1缓存要长5倍，但要比内存快5到10倍。L1缓存和L2缓存是通过SRAM硬件技术实现的。更新的、功能更强大的系统甚至有3级缓存：L1、L2、L3。在缓存背后的思想是：通过利用局部性(程序倾向于访问在局部区域的数据和代码)来获得大又快的内存的效果。通过设置缓存来可能经常被访问的数据，我们可使用高速缓存来执行大部分内存操作。
![图1.8 高速缓存.png](https://upload-images.jianshu.io/upload_images/7066251-bd7615af567c1e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

本书的重要教训之一是**了解告诉缓存的应用可以利用高速缓存来提升程序性能一个数量级**。你将在第6章里学习到更多有关高速缓存的内容，以及如何利用高速缓存等。

## 第1.6节 存储设备形成一个层次结构
**在处理器和一个更大、更慢的设备(比如内存)之间插入一个更小且更快的设备(比如高速缓存)**这种想法被证明是通用的。事实上，在每个计算机系统里的存储设备都被组织成类似图1.9的存储层次结构。在该层次结构里，从上到下，设备是越来越慢、越来越大、越来越便宜。寄存器文件处在层次结构的最顶端，称作L0，占据层级0。我们展示了3级缓存L1到L3，占据存储层级1到3。内存占据层级4，以此类推。
![图1.9 存储层级结构.png](https://upload-images.jianshu.io/upload_images/7066251-f36a42d888000489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


存储层级结构的一个主要思想是：**在某一级的存储可以充当下一级存储的缓存**。因此，寄存器文件是L1缓存的缓存。缓存L1和L2分别是缓存L2和缓存L3的缓存。L3缓存是内存的缓存。内存是磁盘的缓存。在一些具有分布式份文件系统的联网系统里，本地磁盘是存储在其他系统里的数据的缓存。

正如程序员可以利用不同缓存的知识来提升性能一样，程序员也利用利用对整个存储层次结构的理解来提升性能。第6章会对整个存储层次结构做更多的介绍。

## 第1.7节 操作系统管理着硬件
回到hello示例。当shell程序加载和运行hello程序时，当hello程序打印消息时，shell程序和hello程序都没有直接访问键盘、显示器、磁盘和内存。这两个程序都依赖操作系统提供的服务。如图1.10所示，我们可以把操作系统看做是一个软件层，位于应用程序和硬件之间。由应用程序作出的所有操作硬件的尝试都必须经过操作系统。
![图1.10 计算机系统分层视图.png](https://upload-images.jianshu.io/upload_images/7066251-25141aeab016927c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

操作系统主要有两个目标：(1) 保护硬件不受失控应用的滥用(2) 为应用提供一个操作复杂且通常差异很大的底层硬件设备的简单且一致的机制。操作系统通过如图1.11中所示的抽象机制来实现前述两个目标：进程、虚拟内存、文件等。如这张图中所展示的：文件是对I/O设备的抽象，虚拟内存是对内存和磁盘I/O设备的抽象，进程是对处理器、内存、I/O设备的抽象。下面，我们依次来讨论。
### 第1.7.1节 进程
当诸如hello的程序在现代系统上运行时，操作系统提供了一种错觉：
- 该程序是在系统上唯一运行的程序；
- 该程序似乎独占处理器、内存和I/O设备；
- 处理器似乎在不间断地依次执行程序中的指令；
- 程序中的代码和指令似乎是系统内存中唯一的对象；

这些错觉都是由进程的概念提供的，进程的概念是计算机科学中最重要且最成功的思想之一。

一个进程是操作系统对一个运行程序的抽象。多个进程可在同一个系统上并发运行，每个进程似乎独占系统硬件。这里说的并发的意思是：一个进程的指令可以和另一个进程的指令交叉执行。

在大部分系统里，运行的进程要比运行这些的进程的CPU个数多。传统的系统一次仅能执行一个程序，而较新的多核处理器可同时执行多个程序。无论哪一种情况，通过在多个进程之间切换执行，单个CPU似乎能并发执行多个进程。操作系统是通过**上下文切换机制**来实现多进程交叉执行的。为了简化接下来的讨论，我们仅考虑包含单个CPU的单处理器系统。我们将会在第1.9.2节重回到对多处理器的讨论。

操作系统会记录追踪运行一个进程所需的所有状态信息。这种状态信息被称为上线文，包括PC寄存器的当前值、寄存器文件、内存的内容等信息。在任何时刻，单处理器系统仅能执行一个进程的代码。当操作系统决定将控制权交给某个新的进程时，操作系统就执行一次上线文切换：保存当前进程的内容、还原进程的上下文、将控制权交给新进程。新进程从上次被挂起的地方开始执行。图1.12展示了示例hello程序场景的基本思想。
![图1.12 进程上下文切换.png](https://upload-images.jianshu.io/upload_images/7066251-e4bf2e0afccdf20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图1.12所示，从一个进程到另一个进程的切换是受操作系统内核管理的。内核是操作系统代码中常驻内存的部分。当应用需要操作系统提供的某个操作时，比如读写文件等，应用会执行特殊的系统调用指令，将控制权交给内核。然后，内核执行被请求的操作，返回到应用程序。注意：**内核不是一个单独的进程，而是操作系统用来管理所有进程的代码和数据结构的集合**。

实现进程的抽象需要底层硬件和操作系统的紧密配合。我们将在第8章里探究进程抽象如何起作用，以及应用如何创建和控制自身的进程。
### 第1.7.2 线程
虽然我们通常认为一个进程有单个控制流，但是在一个现代系统里，一个进程实际上由多个执行单元(称作**线程**)组成，每个线程都在这个进程的上下文中运行，且共享同样的代码和全局数据。

由于
- 网络服务器对并发的要求；
- 跟多个进程间共享数据相比，在多个线程间共享数据更容易；
- 多线程比多进程更有效率；

等原因，多线程成为一个越来越重要的编程模型。

当有多个处理器可用时，多线程也是一种使得程序运行更快的方式，这一点我们将在第1.9.2节中讲到。你将在第12章里学习并发的基本概念，包括如何编写多线程程序等。

### 第1.7.3 虚拟内存
虚拟内存是一种抽象，为每个进程提供一种“该进程独占内存”的错觉。每个进程有一致的内存视图，即地址空间。图1.13里展示了一个Linux进程的内存视图，即地址空间。
![图1.13 进程的虚拟地址空间.png](https://upload-images.jianshu.io/upload_images/7066251-b3fdc7e613504c5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在Linux系统里，地址空间的最顶部区域是预留给所有进程都共享的操作系统的代码和数据。地址空间的较低区域持有的是用户进程的代码和数据。注意：在图中的地址是由下向上增长的。

每个进程看到的虚拟地址空间由若干个定义良好的区域组成，每个区域都有特定的用途。虽然你将在本书的后面章节里学习更多有关这些区域的知识，但是先从下向上粗略地看一下每个区域：
- 程序代码区和数据区
所有进程的代码都从相同的固定地址开始，接下来是对应全局C变量的数据位置。直接用可执行目标文件的内容来给代码区和数据区初始化。当我们在第7章里研究链接和加载时，你将学习到更多有关地址空间这一部分的知识。
- 堆
紧挨着代码区和数据区的是运行时堆。跟代码区和数据区不一样，堆会随着运行时对C标准库函数的调用(比如`malloc`和`free`)而动态增长和缩小。当我们在第9章学习有关虚拟内存管理时，我们将详细地研究堆。
- 共享库
靠近地址空间中部的区域是一个持有共享库(比如C语言标准库和数学库)代码和数据的区域。共享库是一个功能非常强大但有点难的概念。当我们在第7章中研究动态链接时，你会学习到动态链接库的工作原理。
- 栈
在用户虚拟地址空间的最顶部是用户栈，编译器使用栈来实现函数调用。跟堆一样，用户栈也能在程序执行时动态增长和缩小。特别地，每次我们调用一个函数，用户栈就增长。每次我们从一个函数中返回，用户栈就缩小。你将在第3章里学习到编译器如何使用用户栈。
- 内核虚拟内存
地址空间的最顶部区域是预留给内核的。应用程序不允许读或写这块区域的内容，不允许直接调用定义在内核代码中的函数。应用程序要触发内核让内核来执行这些操作。

为了让虚拟内存生效，需要硬件和操作系统之间的高级交互。基本思路是**将一个进程的虚拟内存的内容存储在磁盘上，然后使用内存作为该磁盘内容的缓存**。第9章会解释虚拟内存机制，以及虚拟内存对现代系统的运行很重要的原因。

### 第1.7.4小节 文件
一个文件不过就是字节序列而已。每个I/O设备(包括磁盘、键盘、显示器、甚至网络)都可抽象为一个文件。使用一小撮Unix I/O系统调用来读写文件，可实现在系统里的所有输入和输出操作。

文件的这种简洁又优雅的概念是功能非常强大的，因为文件给应用提供了一个一致的看待所有各种各样的I/O设备的视图。比如，操作磁盘文件内容的程序员不需要了解具体的磁盘技术。而且，同样的程序可在使用了不同磁盘技术的系统上运行。你将在第10章学习有关Unix I/O的知识。

## 第1.8节 使用网络跟其他系统通信
截止目前我们的系统之旅，我们把系统当做是一个孤立的硬件和软件的集合体。在实践中，现代系统通常通过网络来跟其他系统连接。如图1.14所示，从单个系统的角度来看，网络可看做是另一个I/O设备。
![图1.14 网络是另一个I/O设备.png](https://upload-images.jianshu.io/upload_images/7066251-ca40dd60fe91025f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
当系统从内存中拷贝字节序列到网卡时，数据通过网络流到另一台机器上，而不是流到本地的磁盘驱动。类似地，系统可读取从一台机器发出的数据，将这些数据从网卡拷贝到内存。

随着全球网络(比如因特网)的出现，从一台机器拷贝信息到另一台机器已成为计算机系统最重要的用途之一。比如，诸如电子邮件、即时消息、万维网、FTP以及telnet等应用都是基于这种通过网络拷贝信息的功能的。

回到我们的hello示例，我们可使用熟悉的telnet应用来在一台远程机器上运行hello。





